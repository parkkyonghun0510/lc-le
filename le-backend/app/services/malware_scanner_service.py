"""
Malware scanning service for uploaded files.
Provides multiple scanning strategies including signature-based detection,
file type validation, and integration with external scanning services.
"""

import hashlib
import os
try:
    import magic
    MAGIC_AVAILABLE = True
except ImportError:
    MAGIC_AVAILABLE = False
    magic = None

try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False
    yara = None
import tempfile
import asyncio
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime, timezone
from pathlib import Path
import logging

from app.core.config import settings
from app.core.exceptions import SecurityError

logger = logging.getLogger(__name__)

class MalwareScanResult:
    """Result of malware scanning operation"""
    
    def __init__(
        self,
        is_safe: bool,
        scan_method: str,
        threats_found: List[str] = None,
        file_hash: str = None,
        scan_duration: float = 0.0,
        metadata: Dict[str, Any] = None
    ):
        self.is_safe = is_safe
        self.scan_method = scan_method
        self.threats_found = threats_found or []
        self.file_hash = file_hash
        self.scan_duration = scan_duration
        self.metadata = metadata or {}
        self.scanned_at = datetime.now(timezone.utc)

class MalwareScannerService:
    """
    Comprehensive malware scanning service with multiple detection methods
    """
    
    def __init__(self):
        self.yara_rules = None
        self.known_malware_hashes = set()
        self.suspicious_patterns = []
        self._initialize_scanner()
    
    def _initialize_scanner(self):
        """Initialize scanning components"""
        try:
            # Load YARA rules if available
            self._load_yara_rules()
            
            # Load known malware hash database
            self._load_malware_hashes()
            
            # Initialize suspicious patterns
            self._initialize_patterns()
            
            logger.info("Malware scanner initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize malware scanner: {e}")
            # Continue without advanced scanning if initialization fails
    
    def _load_yara_rules(self):
        """Load YARA rules for malware detection"""
        try:
            if not YARA_AVAILABLE:
                logger.info("YARA not available, skipping rule loading")
                return
                
            rules_path = getattr(settings, 'YARA_RULES_PATH', None)
            if rules_path and os.path.exists(rules_path):
                self.yara_rules = yara.compile(filepath=rules_path)
                logger.info(f"Loaded YARA rules from {rules_path}")
            else:
                # Create basic YARA rules for common threats
                basic_rules = '''
                rule SuspiciousExecutable {
                    meta:
                        description = "Detects suspicious executable patterns"
                    strings:
                        $mz = { 4D 5A }  // MZ header
                        $pe = "PE"
                        $suspicious1 = "cmd.exe" nocase
                        $suspicious2 = "powershell" nocase
                        $suspicious3 = "rundll32" nocase
                    condition:
                        $mz at 0 and $pe and any of ($suspicious*)
                }
                
                rule SuspiciousScript {
                    meta:
                        description = "Detects suspicious script patterns"
                    strings:
                        $js1 = "eval(" nocase
                        $js2 = "document.write" nocase
                        $ps1 = "Invoke-Expression" nocase
                        $ps2 = "DownloadString" nocase
                        $bat1 = "@echo off" nocase
                        $vbs1 = "CreateObject" nocase
                    condition:
                        any of them
                }
                '''
                
                with tempfile.NamedTemporaryFile(mode='w', suffix='.yar', delete=False) as f:
                    f.write(basic_rules)
                    temp_rules_path = f.name
                
                self.yara_rules = yara.compile(filepath=temp_rules_path)
                os.unlink(temp_rules_path)
                logger.info("Loaded basic YARA rules")
                
        except Exception as e:
            logger.warning(f"Could not load YARA rules: {e}")
            self.yara_rules = None
    
    def _load_malware_hashes(self):
        """Load known malware hash database"""
        try:
            # In production, this would load from a threat intelligence feed
            # For now, we'll use a basic set of known bad hashes
            malware_hashes_file = getattr(settings, 'MALWARE_HASHES_FILE', None)
            if malware_hashes_file and os.path.exists(malware_hashes_file):
                with open(malware_hashes_file, 'r') as f:
                    self.known_malware_hashes = set(line.strip().lower() for line in f if line.strip())
                logger.info(f"Loaded {len(self.known_malware_hashes)} malware hashes")
            else:
                # Basic set of known malicious file hashes (examples)
                self.known_malware_hashes = {
                    # These are example hashes - in production, use real threat intelligence
                    "d41d8cd98f00b204e9800998ecf8427e",  # Empty file (suspicious)
                    "5d41402abc4b2a76b9719d911017c592",  # "hello" (test hash)
                }
                logger.info("Using basic malware hash set")
                
        except Exception as e:
            logger.warning(f"Could not load malware hashes: {e}")
            self.known_malware_hashes = set()
    
    def _initialize_patterns(self):
        """Initialize suspicious file patterns"""
        self.suspicious_patterns = [
            # Executable extensions that shouldn't be uploaded
            r'\.exe$', r'\.bat$', r'\.cmd$', r'\.com$', r'\.scr$',
            r'\.pif$', r'\.vbs$', r'\.js$', r'\.jar$', r'\.msi$',
            
            # Script files
            r'\.ps1$', r'\.psm1$', r'\.psd1$',
            
            # Suspicious double extensions
            r'\.(jpg|png|gif|pdf)\.exe$',
            r'\.(doc|docx|xls|xlsx)\.exe$',
            
            # Hidden files with suspicious extensions
            r'^\._.*\.exe$',
        ]
    
    async def scan_file(
        self,
        file_content: bytes,
        filename: str,
        content_type: str = None
    ) -> MalwareScanResult:
        """
        Comprehensive malware scan of file content
        """
        start_time = datetime.now()
        
        try:
            # Calculate file hash
            file_hash = hashlib.sha256(file_content).hexdigest().lower()
            
            # Multiple scanning methods
            scan_results = []
            
            # 1. Hash-based detection
            hash_result = await self._scan_by_hash(file_hash)
            scan_results.append(hash_result)
            
            # 2. File signature validation
            signature_result = await self._scan_file_signature(file_content, filename, content_type)
            scan_results.append(signature_result)
            
            # 3. Pattern-based detection
            pattern_result = await self._scan_patterns(file_content, filename)
            scan_results.append(pattern_result)
            
            # 4. YARA rules scanning
            if self.yara_rules:
                yara_result = await self._scan_with_yara(file_content)
                scan_results.append(yara_result)
            
            # 5. Content analysis
            content_result = await self._analyze_content(file_content, content_type)
            scan_results.append(content_result)
            
            # Combine results
            all_threats = []
            is_safe = True
            scan_methods = []
            
            for result in scan_results:
                if not result.is_safe:
                    is_safe = False
                    all_threats.extend(result.threats_found)
                scan_methods.append(result.scan_method)
            
            scan_duration = (datetime.now() - start_time).total_seconds()
            
            final_result = MalwareScanResult(
                is_safe=is_safe,
                scan_method=", ".join(scan_methods),
                threats_found=list(set(all_threats)),  # Remove duplicates
                file_hash=file_hash,
                scan_duration=scan_duration,
                metadata={
                    "filename": filename,
                    "content_type": content_type,
                    "file_size": len(file_content),
                    "individual_results": [
                        {
                            "method": r.scan_method,
                            "safe": r.is_safe,
                            "threats": r.threats_found
                        } for r in scan_results
                    ]
                }
            )
            
            # Log scan result
            if not is_safe:
                logger.warning(
                    f"Malware detected in file {filename}: "
                    f"threats={all_threats}, hash={file_hash}"
                )
            else:
                logger.info(
                    f"File scan completed: {filename} - CLEAN "
                    f"(duration: {scan_duration:.2f}s)"
                )
            
            return final_result
            
        except Exception as e:
            logger.error(f"Error during malware scan: {e}")
            return MalwareScanResult(
                is_safe=False,
                scan_method="error",
                threats_found=[f"Scan error: {str(e)}"],
                file_hash=hashlib.sha256(file_content).hexdigest().lower(),
                scan_duration=(datetime.now() - start_time).total_seconds()
            )
    
    async def _scan_by_hash(self, file_hash: str) -> MalwareScanResult:
        """Scan file by hash against known malware database"""
        if file_hash in self.known_malware_hashes:
            return MalwareScanResult(
                is_safe=False,
                scan_method="hash_lookup",
                threats_found=[f"Known malware hash: {file_hash[:16]}..."]
            )
        
        return MalwareScanResult(
            is_safe=True,
            scan_method="hash_lookup"
        )
    
    async def _scan_file_signature(
        self,
        file_content: bytes,
        filename: str,
        content_type: str = None
    ) -> MalwareScanResult:
        """Validate file signature matches claimed type"""
        try:
            if not MAGIC_AVAILABLE:
                logger.debug("python-magic not available, skipping signature validation")
                return MalwareScanResult(
                    is_safe=True,
                    scan_method="signature_validation"
                )
                
            # Use python-magic to detect actual file type
            actual_mime = magic.from_buffer(file_content, mime=True)
            
            # Check for mismatched file types (potential disguised malware)
            if content_type and content_type != actual_mime:
                # Allow some common variations
                allowed_variations = {
                    'image/jpg': 'image/jpeg',
                    'image/jpeg': 'image/jpg',
                    'application/msword': 'application/vnd.ms-office',
                }
                
                if not (
                    allowed_variations.get(content_type) == actual_mime or
                    allowed_variations.get(actual_mime) == content_type
                ):
                    return MalwareScanResult(
                        is_safe=False,
                        scan_method="signature_validation",
                        threats_found=[
                            f"File type mismatch: claimed {content_type}, "
                            f"actual {actual_mime}"
                        ]
                    )
            
            # Check for executable files disguised as documents
            if actual_mime in [
                'application/x-executable',
                'application/x-msdos-program',
                'application/x-msdownload'
            ]:
                return MalwareScanResult(
                    is_safe=False,
                    scan_method="signature_validation",
                    threats_found=["Executable file detected"]
                )
            
            return MalwareScanResult(
                is_safe=True,
                scan_method="signature_validation"
            )
            
        except Exception as e:
            logger.warning(f"File signature validation failed: {e}")
            return MalwareScanResult(
                is_safe=True,  # Don't block on signature validation errors
                scan_method="signature_validation"
            )
    
    async def _scan_patterns(self, file_content: bytes, filename: str) -> MalwareScanResult:
        """Scan for suspicious patterns in filename and content"""
        import re
        
        threats = []
        
        # Check filename patterns
        filename_lower = filename.lower()
        for pattern in self.suspicious_patterns:
            if re.search(pattern, filename_lower, re.IGNORECASE):
                threats.append(f"Suspicious filename pattern: {pattern}")
        
        # Check for suspicious content patterns
        try:
            # Convert to string for pattern matching (handle encoding errors)
            try:
                content_str = file_content.decode('utf-8', errors='ignore')
            except:
                content_str = file_content.decode('latin-1', errors='ignore')
            
            suspicious_strings = [
                'eval(',
                'document.write',
                'CreateObject',
                'WScript.Shell',
                'cmd.exe',
                'powershell.exe',
                'Invoke-Expression',
                'DownloadString',
                'base64_decode',
                'exec(',
                'system(',
            ]
            
            for suspicious in suspicious_strings:
                if suspicious.lower() in content_str.lower():
                    threats.append(f"Suspicious content pattern: {suspicious}")
        
        except Exception as e:
            logger.debug(f"Pattern scanning error: {e}")
        
        return MalwareScanResult(
            is_safe=len(threats) == 0,
            scan_method="pattern_analysis",
            threats_found=threats
        )
    
    async def _scan_with_yara(self, file_content: bytes) -> MalwareScanResult:
        """Scan file content with YARA rules"""
        if not YARA_AVAILABLE or not self.yara_rules:
            return MalwareScanResult(is_safe=True, scan_method="yara_rules")
        
        try:
            matches = self.yara_rules.match(data=file_content)
            
            if matches:
                threats = [f"YARA rule matched: {match.rule}" for match in matches]
                return MalwareScanResult(
                    is_safe=False,
                    scan_method="yara_rules",
                    threats_found=threats
                )
            
            return MalwareScanResult(
                is_safe=True,
                scan_method="yara_rules"
            )
            
        except Exception as e:
            logger.warning(f"YARA scanning failed: {e}")
            return MalwareScanResult(
                is_safe=True,  # Don't block on YARA errors
                scan_method="yara_rules"
            )
    
    async def _analyze_content(self, file_content: bytes, content_type: str = None) -> MalwareScanResult:
        """Analyze file content for suspicious characteristics"""
        threats = []
        
        # Check file size anomalies
        if len(file_content) == 0:
            threats.append("Empty file")
        elif len(file_content) > 100 * 1024 * 1024:  # 100MB
            threats.append("Unusually large file size")
        
        # Check for high entropy (possible encrypted/packed malware)
        entropy = self._calculate_entropy(file_content[:1024])  # Check first 1KB
        if entropy > 7.5:  # High entropy threshold
            threats.append(f"High entropy content (possible encryption/packing): {entropy:.2f}")
        
        # Check for null bytes in text files
        if content_type and content_type.startswith('text/'):
            null_count = file_content.count(b'\x00')
            if null_count > len(file_content) * 0.01:  # More than 1% null bytes
                threats.append("Excessive null bytes in text file")
        
        return MalwareScanResult(
            is_safe=len(threats) == 0,
            scan_method="content_analysis",
            threats_found=threats
        )
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0
        
        # Count byte frequencies
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        # Calculate entropy
        import math
        entropy = 0
        data_len = len(data)
        for count in byte_counts:
            if count > 0:
                probability = count / data_len
                entropy -= probability * math.log2(probability)
        
        return entropy
    
    async def scan_url_reputation(self, url: str) -> MalwareScanResult:
        """
        Check URL reputation (for future use with external file sources)
        """
        # This would integrate with URL reputation services
        # For now, basic implementation
        
        suspicious_domains = [
            'bit.ly', 'tinyurl.com', 'goo.gl',  # URL shorteners
            'tempfile.org', 'filebin.net',      # Temporary file hosts
        ]
        
        threats = []
        for domain in suspicious_domains:
            if domain in url.lower():
                threats.append(f"Suspicious domain: {domain}")
        
        return MalwareScanResult(
            is_safe=len(threats) == 0,
            scan_method="url_reputation",
            threats_found=threats
        )

# Global scanner instance
malware_scanner = MalwareScannerService()

async def scan_file_for_malware(
    file_content: bytes,
    filename: str,
    content_type: str = None
) -> MalwareScanResult:
    """
    Convenience function to scan a file for malware
    """
    return await malware_scanner.scan_file(file_content, filename, content_type)